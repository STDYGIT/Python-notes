# Python Programming Exam Notes
## Complete Study Guide (2022-2024)

---

# 2022 Exam Questions

## Question 1: Assigning Values to Variables

### Core Concept: Variable Assignment & Dynamic Typing

**Key Points:**
- Variables are references/labels that point to objects in memory
- No type declaration needed (dynamic typing)
- Python automatically determines type based on value
- Assignment operator: `=`

### Code Examples:

```python
# Simple Assignment
x = 10          # x points to an integer object 10
name = "Jatin"  # name points to a string object

# Multiple Assignment (Tuple Unpacking)
a, b, c = 1, 2, 3
# a becomes 1, b becomes 2, c becomes 3

# Chained Assignment
x = y = z = 0   # All three variables point to the same object 0

# Dynamic Re-typing
var = 100       # var is an int
print(var)
var = "Now I am a string"  # Valid in Python! var now points to a string
print(var)
```

**Important Rules:**
- Variables created when first assigned
- Names must start with letter or underscore (not number)
- Python is case-sensitive (`Age` ‚â† `age`)

---

## Question 2: For-Loop Syntax

### Core Concept: Iteration & Control Flow

**Syntax:**
```python
for item in sequence:
    statements
```

### Code Examples:

```python
# Example 1: Iterating over a list
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)

# Example 2: Using range()
# range(start, stop, step)
for i in range(0, 10, 2):
    print(i)  # Prints 0, 2, 4, 6, 8

# Example 3: Else block in for loop
# Executed when loop is exhausted (not broken)
for x in range(3):
    print(x)
else:
    print("Loop finished!")
```

**Key Points:**
- Loop body must be indented
- `range()` commonly used for number sequences
- `break` stops loop; `continue` skips current iteration

---

## Question 3: Method Resolution Order (MRO)

### Core Concept: Inheritance & Multiple Inheritance

**Definition:** MRO is the specific order Python looks for methods in a class hierarchy. Crucial for multiple inheritance.

**Algorithm:** Python uses C3 Linearization to determine order

### Code Example:

```python
class A:
    def process(self):
        print("A process")

class B(A):
    def process(self):
        print("B process")

class C(A):
    def process(self):
        print("C process")

class D(B, C):
    pass

obj = D()
obj.process()
# Output: "B process"

# Check MRO:
print(D.mro())
# Output: [<class '__main__.D'>, <class '__main__.B'>, 
#          <class '__main__.C'>, <class '__main__.A'>, 
#          <class 'object'>]
```

**Lookup Order:** D ‚Üí B ‚Üí C ‚Üí A

---

## Question 4: The stamp() Method

### Core Concept: Turtle Graphics

**Purpose:** Leaves an impression (copy) of the turtle's shape at current position

```python
import turtle

t = turtle.Turtle()
t.shape("turtle")

t.forward(100)
id_1 = t.stamp()  # Leaves a copy at (100,0)
t.forward(100)

# Can clear specific stamps later
# t.clearstamp(id_1)
```

**Key Points:**
- Returns `stamp_id` for later deletion
- Does not move turtle, just stamps image
- Different from `dot()` which draws a circle

---

## Question 5: IDLE vs. Spyder

### Comparison Table:

| Feature | IDLE | Spyder |
|---------|------|--------|
| **Complexity** | Lightweight, simple | Feature-rich, heavyweight |
| **Audience** | Beginners, education | Data Scientists, Engineers |
| **Features** | Basic syntax highlighting, simple debugger | Variable explorer, advanced debugging, plot viewer |
| **Interface** | Minimalist | Multi-pane layout |
| **Installation** | Default with Python | Part of Anaconda |

---

## Question 6: Python Syntax Basics

### (a) Python Statement
An instruction the Python interpreter can execute
```python
x = 1          # Assignment statement
print("hello") # Function call statement
```

### (b) Multiline Statement
Extending statements across multiple lines

```python
# Explicit continuation with backslash
total = 1 + \
        2 + \
        3

# Implicit continuation (preferred)
colors = ['red',
          'blue',
          'green']
```

### (c) Python Indentation
Whitespace at line beginning defines code blocks (mandatory, not cosmetic)

```python
if x > 0:
    print("Positive")  # Indented = inside if block
    print("Number")    # Same level = same block
print("Done")          # Not indented = outside block
```

### (d) Python Comments

```python
# Single-line comment

'''
Multi-line comment
(technically a docstring)
'''
```

---

## Question 7: Square Root Without Built-in Functions

### Method 1: Exponentiation Operator (Simple)

```python
number = float(input("Enter a number: "))
sqrt_val = number ** 0.5
print(f"Square root of {number} is {sqrt_val}")
```

### Method 2: Newton's Method (Algorithmic)

```python
n = float(input("Enter a number: "))
approx = 0.5 * n  # Initial guess
better = 0.5 * (approx + n/approx)

while better != approx:
    approx = better
    better = 0.5 * (approx + n/approx)

print(f"Square root is {approx}")
```

---

## Question 8: Python Strings

### Core Concept: Immutable Character Sequences

**Key Features:**
- Enclosed in `'` or `"`
- Immutable (cannot be changed after creation)
- Support indexing and slicing

```python
s = "Python Programming"

# Indexing
print(s[0])      # P
print(s[-1])     # g (last char)

# Slicing
print(s[0:6])    # Python

# Immutability
# s[0] = "J"     # ERROR! Cannot assign
s = "J" + s[1:]  # Workaround: Create new string

# Common Methods
print(s.upper())           # JPYTHON PROGRAMMING
print(s.lower())           # jpython programming
print(s.replace("J", "P")) # Python Programming

# F-strings (formatting)
name = "Alice"
age = 25
print(f"{name} is {age} years old")
```

---

## Question 11: Pandas (DataFrames)

### Core Concept: Data Analysis Library

**Main Data Structures:**
- **Series:** 1D labeled array (like a column)
- **DataFrame:** 2D labeled data structure (like a table)

```python
import pandas as pd

# Creating a DataFrame from dictionary
data = {
    'Name': ['Jatin', 'Alice', 'Bob'],
    'Age': [20, 22, 21],
    'City': ['Delhi', 'Mumbai', 'Chennai']
}

df = pd.DataFrame(data)
print(df)

# Accessing a column
print(df['Name'])

# Filtering data (Students older than 20)
filtered = df[df['Age'] > 20]
print(filtered)

# Adding a new column
df['Grade'] = ['A', 'B', 'A']

# Basic statistics
print(df.describe())
```

---

## Question 12: CSV and JSON Files

### CSV (Comma Separated Values)
Simple text format for tabular data

### JSON (JavaScript Object Notation)
Lightweight data interchange format

### JSON Module Example:

```python
import json

# Python Dictionary
data = {
    "name": "Jatin",
    "skills": ["Python", "Flask", "React"],
    "active": True
}

# Serialization (Python ‚Üí JSON String)
json_string = json.dumps(data)
print(json_string)

# Deserialization (JSON String ‚Üí Python)
parsed_data = json.loads(json_string)
print(parsed_data["skills"][0])  # Access "Python"

# Writing to a file
with open("data.json", "w") as f:
    json.dump(data, f, indent=4)

# Reading from a file
with open("data.json", "r") as f:
    loaded_data = json.load(f)
```

---

## Question 13: Merging Data Sets

### Three Main Methods in Pandas:

**1. concat():** Stacking dataframes

```python
import pandas as pd

df1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})
df2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})

# Vertical stacking
result = pd.concat([df1, df2], ignore_index=True)
```

**2. merge():** Database-style joins

```python
df1 = pd.DataFrame({'ID': [1, 2], 'Name': ['A', 'B']})
df2 = pd.DataFrame({'ID': [1, 2], 'Score': [90, 80]})

# Inner join on 'ID'
merged_df = pd.merge(df1, df2, on='ID')
print(merged_df)
#    ID Name  Score
# 0   1    A     90
# 1   2    B     80

# Different join types
left_join = pd.merge(df1, df2, on='ID', how='left')
outer_join = pd.merge(df1, df2, on='ID', how='outer')
```

**3. join():** Joining on indices

---

# 2023 Exam Questions

## Question 1: The type() Function

### Core Concept: Data Type Introspection

**Purpose:** Returns the class type of any variable/value

```python
# Basic usage
x = 10
y = "Hello"
z = [1, 2, 3]

print(type(x))  # <class 'int'>
print(type(y))  # <class 'str'>
print(type(z))  # <class 'list'>

# Practical application: Type checking
def add_numbers(a, b):
    if type(a) is int and type(b) is int:
        return a + b
    else:
        return "Error: Inputs must be integers"

print(add_numbers(5, 3))      # 8
print(add_numbers(5, "3"))    # Error message
```

**Note:** Use `isinstance()` for inheritance-aware checks

---

## Question 2: Python Path Environment Variable

### Core Concept: Module Search Path

**PYTHONPATH:** Environment variable telling Python where to look for modules

**Search Order:**
1. Current directory
2. Directories in PYTHONPATH
3. Standard library directories

**Example:**
```bash
# Setting PYTHONPATH (Linux/Mac)
export PYTHONPATH=/path/to/my/modules

# Setting PYTHONPATH (Windows)
set PYTHONPATH=C:\path\to\my\modules
```

**Check in Python:**
```python
import sys
print(sys.path)  # Shows all search paths
```

---

## Question 3: Lambda Functions

### Core Concept: Anonymous Functions

**Syntax:** `lambda arguments : expression`

```python
# Standard function
def add(x, y):
    return x + y

# Equivalent Lambda function
add_lambda = lambda x, y: x + y

print(add_lambda(5, 3))  # Output: 8

# Practical Application: map()
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # [1, 4, 9, 16]

# Practical Application: filter()
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4]

# Practical Application: sorted() with key
points = [(2, 3), (1, 2), (4, 1)]
sorted_points = sorted(points, key=lambda p: p[1])
print(sorted_points)  # [(4, 1), (1, 2), (2, 3)]
```

**Limitations:**
- Single expression only
- No statements (return, pass, assert)
- Use `def` for complex logic

---

## Question 4: Python Arrays vs. Lists

### Comparison:

| Feature | Lists | Arrays |
|---------|-------|--------|
| **Type** | Built-in | Module (array/NumPy) |
| **Data Types** | Heterogeneous (mixed) | Homogeneous (same type) |
| **Memory** | More memory | Memory efficient |
| **Performance** | Flexible but slower | Faster for numerical ops |

```python
import array

# LIST: Mixed types allowed
my_list = [1, "Hello", 3.14]
my_list.append(True)  # No problem

# ARRAY: Must be same type
my_array = array.array('i', [1, 2, 3])  # 'i' = signed integer
my_array.append(4)  # OK
# my_array.append("Hello")  # TypeError!

# Type codes for arrays:
# 'i' = signed int
# 'f' = float
# 'd' = double
# 'b' = signed char
```

---

## Question 5: Code Output Analysis

### Given Code:
```python
TXT = ["20", "50", "30", "40"]
CNT = 3
TOTAL = 0
for C in [7, 5, 4, 6]:
    T = TXT[CNT]
    TOTAL = float(T) + C
    print(TOTAL)
    CNT -= 1
```

### Execution Trace:

| Iteration | C | CNT | T (TXT[CNT]) | TOTAL | Output |
|-----------|---|-----|--------------|-------|--------|
| 1 | 7 | 3 | "40" | 40.0 + 7 = 47.0 | 47.0 |
| 2 | 5 | 2 | "30" | 30.0 + 5 = 35.0 | 35.0 |
| 3 | 4 | 1 | "50" | 50.0 + 4 = 54.0 | 54.0 |
| 4 | 6 | 0 | "20" | 20.0 + 6 = 26.0 | 26.0 |

**Final Output:**
```
47.0
35.0
54.0
26.0
```

---

## Question 6: Exceptions in Python

### Core Concept: Error Handling

**Common Built-in Exceptions:**
- `ZeroDivisionError` - Division by zero
- `ValueError` - Wrong value type
- `TypeError` - Wrong operation for type
- `FileNotFoundError` - Missing file
- `IndexError` - Index out of range
- `KeyError` - Missing dictionary key

```python
# Basic exception handling
try:
    num = int(input("Enter a number: "))
    result = 10 / num
except ZeroDivisionError:
    print("Cannot divide by zero!")
except ValueError:
    print("That was not a valid number.")
else:
    print(f"Result is {result}")  # Runs if no exception
finally:
    print("Execution complete.")  # Always runs

# Catching multiple exceptions
try:
    # risky code
    pass
except (ValueError, TypeError) as e:
    print(f"Error: {e}")

# Custom exceptions
class CustomError(Exception):
    pass

raise CustomError("Something went wrong!")
```

---

## Question 7: Tuples and Unpacking

### Core Concept: Immutable Sequences

```python
# Tuple creation
my_tuple = (10, 20, 30)
# my_tuple[0] = 5  # ERROR: Tuples are immutable

# Single element tuple (note the comma!)
single = (5,)  # Correct
not_tuple = (5)  # This is just an int!

# Basic unpacking
a, b, c = my_tuple
print(a)  # 10
print(b)  # 20

# Advanced unpacking with *
head, *tail = (1, 2, 3, 4, 5)
print(head)  # 1
print(tail)  # [2, 3, 4, 5]

*beginning, last = (1, 2, 3, 4, 5)
print(beginning)  # [1, 2, 3, 4]
print(last)       # 5

first, *middle, last = (1, 2, 3, 4, 5)
print(middle)  # [2, 3, 4]

# Swapping variables
x, y = 5, 10
x, y = y, x  # Swap using tuple unpacking
print(x, y)  # 10, 5
```

---

## Question 8: Loop Structures

### While Loop (Indefinite iteration)

```python
# Basic while loop
count = 0
while count < 3:
    print(count)
    count += 1

# While with else
n = 5
while n > 0:
    print(n)
    n -= 1
else:
    print("Countdown finished!")

# Infinite loop (use with caution!)
# while True:
#     user_input = input("Enter 'quit' to exit: ")
#     if user_input == 'quit':
#         break
```

### For Loop (Definite iteration)

```python
# Iterating over list
fruits = ["apple", "banana"]
for fruit in fruits:
    print(fruit)

# Using range
for i in range(5):
    print(i)  # 0, 1, 2, 3, 4

# For with else
for i in range(3):
    print(i)
else:
    print("Loop completed normally")

# break and continue
for i in range(10):
    if i == 3:
        continue  # Skip 3
    if i == 7:
        break     # Stop at 7
    print(i)
```

---

## Question 9: Python IDE

### Core Concept: Integrated Development Environment

**Components of an IDE:**
1. **Source Code Editor** - Syntax highlighting, autocomplete
2. **Debugger** - Step through code, inspect variables
3. **Build Automation** - Run scripts easily
4. **Version Control** - Git integration

**Popular Python IDEs:**
- **PyCharm** - Professional, feature-rich
- **VS Code** - Lightweight, extensible
- **Spyder** - Scientific computing
- **Jupyter Notebook** - Interactive data analysis
- **IDLE** - Built-in, for beginners

---

## Question 10: File Input and Output

### Core Concept: Data Persistence

**File Modes:**
- `'r'` - Read (default)
- `'w'` - Write (overwrites)
- `'a'` - Append
- `'x'` - Create (fails if exists)
- `'b'` - Binary mode
- `'+'` - Read and write

```python
# Writing to a file (best practice with 'with')
with open("data.txt", "w") as file:
    file.write("Hello World\n")
    file.write("Python is great")

# Reading entire file
with open("data.txt", "r") as file:
    content = file.read()
    print(content)

# Reading line by line
with open("data.txt", "r") as file:
    for line in file:
        print(line.strip())  # strip() removes \n

# Reading all lines into list
with open("data.txt", "r") as file:
    lines = file.readlines()
    print(lines)

# Appending to file
with open("data.txt", "a") as file:
    file.write("\nNew line added")

# Binary files
with open("image.jpg", "rb") as file:
    binary_data = file.read()
```

---

## Question 11: Pandas - Combining DataFrames

### Three Main Methods:

**1. concat() - Stacking**
```python
import pandas as pd

df1 = pd.DataFrame({'id': [1, 2], 'val': ['a', 'b']})
df2 = pd.DataFrame({'id': [3, 4], 'val': ['c', 'd']})

# Vertical concatenation (default axis=0)
combined = pd.concat([df1, df2], ignore_index=True)

# Horizontal concatenation
combined_horizontal = pd.concat([df1, df2], axis=1)
```

**2. merge() - Database-style joins**
```python
df1 = pd.DataFrame({'id': [1, 2, 3], 'name': ['A', 'B', 'C']})
df2 = pd.DataFrame({'id': [1, 2, 4], 'score': [90, 80, 70]})

# Inner join (default)
inner = pd.merge(df1, df2, on='id')
# Result: Only matching IDs (1, 2)

# Left join
left = pd.merge(df1, df2, on='id', how='left')
# Result: All from df1, matching from df2

# Right join
right = pd.merge(df1, df2, on='id', how='right')
# Result: All from df2, matching from df1

# Outer join
outer = pd.merge(df1, df2, on='id', how='outer')
# Result: All records from both
```

---

## Question 12: Dictionaries, Imports, and Assert

### Dictionaries

```python
# Creation
student = {"name": "John", "age": 20, "grade": "A"}

# Accessing values
print(student["name"])       # John
print(student.get("age"))    # 20
print(student.get("major", "Not specified"))  # Default value

# Adding/Updating
student["major"] = "CS"
student["age"] = 21

# Removing
del student["grade"]
removed_value = student.pop("major")

# Methods
print(student.keys())    # dict_keys(['name', 'age'])
print(student.values())  # dict_values(['John', 21])
print(student.items())   # dict_items([('name', 'John'), ('age', 21)])

# Looping
for key, value in student.items():
    print(f"{key}: {value}")
```

### Import Statements

```python
# Generic import
import math
print(math.sqrt(16))

# Specific import
from math import sqrt, pi
print(sqrt(16))

# Aliased import
import pandas as pd
df = pd.DataFrame()

# Import everything (not recommended)
from math import *
```

### Assert Statement

```python
# Basic assert
x = 5
assert x > 0, "x must be positive"  # Passes

# assert x < 0, "x must be negative"  # Raises AssertionError

# Practical usage in functions
def calculate_average(numbers):
    assert len(numbers) > 0, "List cannot be empty"
    return sum(numbers) / len(numbers)

# Using in testing
def divide(a, b):
    assert b != 0, "Cannot divide by zero"
    return a / b
```

---

## Question 13: Programming Logic

### (a) Leap Year Test

**Rules:**
- Divisible by 4: Leap year
- EXCEPT divisible by 100: Not leap year
- UNLESS also divisible by 400: Leap year

```python
def is_leap(year):
    if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
        return True
    return False

# Test cases
print(is_leap(2024))  # True (divisible by 4)
print(is_leap(1900))  # False (divisible by 100 but not 400)
print(is_leap(2000))  # True (divisible by 400)

# One-liner version
is_leap_short = lambda y: y % 4 == 0 and (y % 100 != 0 or y % 400 == 0)
```

### (b) Armstrong Number

**Definition:** Sum of digits raised to power of digit count equals number

Examples: 153 = 1¬≥ + 5¬≥ + 3¬≥ = 1 + 125 + 27 = 153

```python
def is_armstrong(num):
    # Convert to string to get digits
    s_num = str(num)
    power = len(s_num)
    
    # Calculate sum of digits^power
    total = sum(int(digit) ** power for digit in s_num)
    
    return total == num

# Test cases
print(is_armstrong(153))   # True (3 digits)
print(is_armstrong(9474))  # True (4 digits)
print(is_armstrong(123))   # False

# Detailed version
def is_armstrong_detailed(num):
    original = num
    n_digits = len(str(num))
    sum_powers = 0
    
    while num > 0:
        digit = num % 10
        sum_powers += digit ** n_digits
        num //= 10
    
    return sum_powers == original
```

# Python Programming Guide
## Complete Reference with Code Examples

---

## Question 1: Python Language Features

**Core Concept:** Introduction to Python and its capabilities

### Prerequisites
- Basic understanding of what a programming language is
- Familiarity with the difference between compilation and interpretation

### Detailed Explanation

Python is a high-level, general-purpose programming language known for its simplicity and readability. It emphasizes code readability with its notable use of significant indentation. It is designed to be easy to learn for beginners while powerful enough for experts.

### Theoretical Deep Dive

- **Interpreted:** Python is processed at runtime by the interpreter. You do not need to compile your program before executing it.
- **Dynamically Typed:** You do not need to declare the type of a variable when you create one. The type is determined at runtime.
- **Object-Oriented:** Python supports Object-Oriented style or technique of programming that encapsulates code within objects.
- **Extensive Standard Library:** Python is often described as "batteries included" due to its vast library for tasks ranging from regular expressions to documentation generation and unit testing.
- **Portable:** Python can run on a wide variety of hardware platforms and has the same interface on all platforms.

### Key Points to Remember
- Python is case-sensitive
- It uses indentation to define blocks of code (instead of curly braces `{}`)

### Common Mistakes/Misconceptions
‚ö†Ô∏è **Mistake:** Confusing Python's dynamic typing with "weak typing." Python is strongly typed (e.g., you cannot blindly add a string to an integer).

---

## Question 2: Strings in Python

**Core Concept:** String Definition and Creation

### Prerequisites
- Variables and assignment
- Concept of text data types

### Detailed Explanation

A string is a sequence of characters used to store and manipulate text. In Python, strings are **immutable**, meaning once created, their content cannot be changed.

### Code Examples

```python
# 1. Single Quotes
name = 'John'

# 2. Double Quotes (Useful if the string contains a single quote)
sentence = "It's a sunny day."

# 3. Triple Quotes (For multi-line strings)
paragraph = """This is a string
that spans multiple
lines."""

print(type(name))  # Output: <class 'str'>
```

### Key Points to Remember
- Strings can be indexed (accessed by position) starting at 0

### Common Mistakes/Misconceptions
‚ö†Ô∏è **Mistake:** Trying to change a character in a string directly (e.g., `s[0] = 'A'`) results in a `TypeError`.

---

## Question 3: Lists vs. Tuples

**Core Concept:** Mutable vs. Immutable Data Structures

### Prerequisites
- Understanding of sequences/arrays
- Concept of mutability

### Detailed Explanation

Both Lists and Tuples are sequence data types that can store a collection of items. The fundamental difference lies in mutability.

| Feature | List | Tuple |
|---------|------|-------|
| **Mutability** | Mutable (can be changed) | Immutable (cannot be changed) |
| **Syntax** | Square brackets `[]` | Parentheses `()` |
| **Performance** | Slower (due to dynamic nature) | Faster (memory efficient) |
| **Use Case** | Collections of items that may change | Fixed collections (e.g., coordinates) |

### Code Examples

```python
# LIST
my_list = [1, 2, 3]
my_list[0] = 100    # Allowed
print(my_list)      # Output: [100, 2, 3]

# TUPLE
my_tuple = (1, 2, 3)
# my_tuple[0] = 100 # Error: 'tuple' object does not support item assignment
```

### Key Points to Remember
- Use tuples for data that should not change to ensure data integrity

### Common Mistakes/Misconceptions
‚ö†Ô∏è **Mistake:** Thinking tuples with one element are defined like `(1)`. They must have a trailing comma: `(1,)`.

---

## Question 4: Modules in Python

**Core Concept:** Code Modularity and Reusability

### Prerequisites
- Functions and variable scope
- File systems (how files are stored)

### Detailed Explanation

A module is simply a file containing Python definitions and statements. The file name is the module name with the suffix `.py`. Modules help organize code into separate files, making it easier to manage and reuse.

### Code Examples

**File: my_math.py**
```python
def add(a, b):
    return a + b
```

**File: main.py**
```python
import my_math

result = my_math.add(5, 3)
print(result)  # Output: 8
```

### Key Points to Remember
- Modules prevent variable name clashes across different parts of a program

---

## Question 5: Packages

**Core Concept:** Hierarchical File Organization

### Prerequisites
- Modules (Question 4)
- Directory structures

### Detailed Explanation

A package is a collection of Python modules organized in a directory hierarchy. In simpler terms, a package is a directory that contains a special file called `__init__.py` (and potentially other modules and sub-packages).

### Theoretical Deep Dive

To create a package:
1. Create a directory (e.g., `sound`)
2. Add an `__init__.py` file to it (can be empty)
3. Add modules (e.g., `effects.py`) inside the directory

### Structure Example

```
sound/               <-- Top-level Package
    __init__.py      <-- Initializes the package
    effects.py       <-- Module
    filters.py       <-- Module
```

**Usage:** `import sound.effects`

### Key Points to Remember
- The `__init__.py` file is required to make Python treat the directory as a package

---

## Question 6: Control Flow (Break, Continue, Pass)

**Core Concept:** Loop Control Statements

### Prerequisites
- `for` and `while` loops

### Detailed Explanation

These statements alter the normal flow of a loop:

- **Break:** Terminates the loop entirely and transfers execution to the statement immediately following the loop
- **Continue:** Skips the rest of the code inside the current loop iteration and jumps to the next iteration
- **Pass:** A null operation; nothing happens. It is used as a placeholder for future code

### Code Examples

```python
for i in range(5):
    if i == 2:
        continue  # Skips printing 2
    if i == 4:
        break     # Stops before printing 4
    print(i)
# Output: 0, 1, 3

def future_function():
    pass  # Code to be added later
```

### Common Mistakes/Misconceptions
‚ö†Ô∏è **Mistake:** Confusing `pass` with `continue`. `pass` executes and moves to the next line; `continue` halts the current iteration immediately.

---

## Question 7: Missing Values in Pandas

**Core Concept:** Data Cleaning in DataFrames

### Prerequisites
- Basic understanding of Pandas DataFrames
- Concept of NaN (Not a Number)

### Detailed Explanation

Real-world data often has missing values (represented as `NaN` or `None`).

**Identifying Missing Values:**
- `df.isnull()`: Returns a DataFrame of booleans (True if missing)
- `df.isnull().sum()`: Returns the count of missing values per column

**Dealing with Missing Values:**
- **Dropping:** `df.dropna()` removes rows/columns with nulls
- **Filling (Imputation):** `df.fillna(value)` replaces nulls with a specific value (e.g., 0 or the mean)

### Code Examples

```python
import pandas as pd
import numpy as np

df = pd.DataFrame({'A': [1, np.nan, 3], 'B': [4, 5, np.nan]})

# Check for missing
print(df.isnull().sum())

# Fill missing with 0
df_filled = df.fillna(0)
```

### Key Points to Remember
- Always check how much data you will lose before using `dropna()`

---

## Question 8: Updating Lists

**Core Concept:** List Mutability and Methods

### Prerequisites
- List creation and indexing

### Detailed Explanation

Lists are mutable, meaning elements can be modified, added, or removed after creation.

### Code Examples

```python
my_list = [1, 2, 3]

# 1. Updating via Index
my_list[1] = 20      # [1, 20, 3]

# 2. append(): Adds element to the end
my_list.append(4)    # [1, 20, 3, 4]

# 3. insert(): Adds element at specific index
my_list.insert(0, 9) # [9, 1, 20, 3, 4]

# 4. extend(): Appends elements from another iterable
my_list.extend([5, 6])
```

### Common Mistakes/Misconceptions
‚ö†Ô∏è **Mistake:** `append()` takes exactly one argument. You cannot do `list.append(1, 2)`. Use `extend()` or append a list `[1, 2]`.

---

## Question 9: Python Files

**Core Concept:** File I/O (Input/Output)

### Prerequisites
- Path handling
- Data persistence concepts

### Detailed Explanation

File handling allows Python to read from and write to files on your computer.

- **Opening a File:** `open(filename, mode)` returns a file object
- **Modes:** `'r'` (read), `'w'` (write - overwrites), `'a'` (append), `'x'` (create), `'b'` (binary)

**Functions/Operations:**
- `read()`: Reads the entire file
- `readline()`: Reads a single line
- `write()`: Writes a string to the file
- `close()`: Closes the file (crucial for resource management)

### Code Examples

```python
# Writing to a file using 'with' (automatically closes file)
with open('test.txt', 'w') as f:
    f.write("Hello, World!")

# Reading from a file
with open('test.txt', 'r') as f:
    content = f.read()
    print(content)
```

### Key Points to Remember
- Always use the `with` statement. It ensures the file is closed properly even if an error occurs

---

## Question 10: (a) Conditional Structures & (b) Import

**Core Concept:** Decision Making and Library Integration

### Prerequisites
- Boolean logic (True/False)
- Comparison operators (`>`, `<`, `==`)

### Detailed Explanation

#### (a) Conditional Structures

These allow the program to execute different blocks of code based on conditions:

- **if:** Executes if condition is True
- **if...else:** Executes one block if True, another if False
- **if...elif...else:** Checks multiple conditions in sequence

```python
x = 10
if x > 10:
    print("Greater")
elif x == 10:
    print("Equal")
else:
    print("Smaller")
```

#### (b) Import Statement

Used to bring external code (modules) into your current script:

- `import math`: Imports the whole module. Usage: `math.sqrt(4)`
- `from math import sqrt`: Imports specific function. Usage: `sqrt(4)`
- `import pandas as pd`: Imports with an alias. Usage: `pd.DataFrame()`

---

## Question 11: Basic List Operations

**Core Concept:** List Syntax and Manipulation

### Prerequisites
- List creation

### Detailed Explanation

Beyond methods, lists support various operators:

- **Concatenation (+):** Joins two lists
- **Repetition (*):** Repeats a list
- **Membership (in):** Checks if an item exists in the list
- **Slicing ([:]): ** Accesses a subset of the list
- **Length (len()):** Returns the number of items

### Code Examples

```python
a = [1, 2]
b = [3, 4]

print(a + b)      # [1, 2, 3, 4]
print(a * 2)      # [1, 2, 1, 2]
print(1 in a)     # True
print(b[0:1])     # [3] (Slicing)
```

---

## Question 12: (a) Sum Program & (b) Exceptions

**Core Concept:** Algorithms and Error Handling

### Prerequisites
- Loops (for sum)
- Understanding of runtime errors (for exceptions)

### Detailed Explanation

#### (a) Sum of List

```python
def calculate_sum(numbers):
    total = 0
    for num in numbers:
        total += num
    return total

nums = [10, 20, 30]
print(calculate_sum(nums))  # Output: 60
# Pythonic way: print(sum(nums))
```

#### (b) Exceptions

Exceptions are errors detected during execution.

**Common Types:**
- `ZeroDivisionError`: Dividing by zero
- `TypeError`: Operation on inappropriate types
- `ValueError`: Function receives right type but inappropriate value
- `IndexError`: Accessing index out of range

**Handling:** Use `try...except` blocks

```python
try:
    num = int(input("Enter a number: "))
    result = 10 / num
    print(result)
except ZeroDivisionError:
    print("Cannot divide by zero!")
except ValueError:
    print("Please enter a valid integer.")
```

### Key Points to Remember
- Exception handling prevents the program from crashing unexpectedly

---

## Question 13: Pandas Library

**Core Concept:** Data Analysis and Structures

### Prerequisites
- Lists and Dictionaries
- NumPy basics (helpful but not strictly required)

### Detailed Explanation

Pandas is a powerful library for data manipulation and analysis.

**Data Structures:**
- **Series:** One-dimensional array (like a column in Excel)
- **DataFrame:** Two-dimensional data structure (like a table in Excel)

**Significant Features:**
- Handling of missing data
- Size mutability: Columns can be inserted/deleted
- Powerful "group by" functionality
- Easy converting between different formats (CSV, Excel, SQL)

### Code Examples

```python
import pandas as pd

# Creating a Series
s = pd.Series([1, 3, 5])

# Creating a DataFrame
data = {'Name': ['Tom', 'Jerry'], 'Age': [20, 21]}
df = pd.DataFrame(data)

print(df)
# Output:
#    Name  Age
# 0   Tom   20
# 1 Jerry   21
```

### Key Points to Remember
- The DataFrame is the most commonly used object in Pandas. It is essentially a dictionary of Series objects

---

## Summary

This guide covers the fundamental concepts of Python programming, from basic language features to advanced data manipulation with Pandas. Each section includes:

- Clear explanations of core concepts
- Prerequisites for understanding
- Practical code examples
- Key points to remember
- Common mistakes to avoid

**Happy Coding! üêç**
